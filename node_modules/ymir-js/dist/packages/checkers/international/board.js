"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var getAvailableColumns_1 = require("../../../utils/getAvailableColumns");
var board_1 = require("../../core/board");
var item_1 = require("./item");
var InternationalCheckersBoard = /** @class */ (function (_super) {
    __extends(InternationalCheckersBoard, _super);
    function InternationalCheckersBoard(config) {
        if (config === void 0) { config = { x: 10, y: 10 }; }
        var _this = _super.call(this, config) || this;
        _this.getAvailableCoordsByColor = function (color) {
            var currentItems = [];
            var availableCoords = {};
            Object.entries(_this.board).forEach(function (_a) {
                var coord = _a[0], col = _a[1];
                if (col.item && col.item.color === color) {
                    currentItems.push(coord);
                }
            });
            currentItems.forEach(function (coord) {
                var item = _this.getItem(coord);
                var currentAvailableCoords = _this.getAvailableColumns(coord, item.movement);
                if (currentAvailableCoords.length) {
                    availableCoords[coord] = currentAvailableCoords;
                }
            });
            return availableCoords;
        };
        _this.getAttackCoordsByColor = function (color) {
            var availableCoords = _this.getAvailableCoordsByColor(color);
            var attackCoords = {};
            Object.entries(availableCoords).forEach(function (_a) {
                var coord = _a[0], currentAvailableCoords = _a[1];
                currentAvailableCoords.forEach(function (currentAvailableCoord) {
                    var destroyItemCoord = _this.getItemsBetweenTwoCoords(coord, currentAvailableCoord)[0];
                    if (destroyItemCoord) {
                        if (attackCoords[coord]) {
                            attackCoords[coord].push({
                                coord: currentAvailableCoord,
                                destroyItemCoord: destroyItemCoord,
                            });
                        }
                        else {
                            attackCoords[coord] = [
                                { coord: currentAvailableCoord, destroyItemCoord: destroyItemCoord },
                            ];
                        }
                    }
                });
            });
            return attackCoords;
        };
        _this.getDefendCoordsByColor = function (color) {
            var defendCoords = {};
            var enemyColor = color === 'white' ? 'black' : 'white';
            var availableCoords = _this.getAvailableCoordsByColor(color);
            var enemyAttackCoords = _this.getAttackCoordsByColor(enemyColor);
            Object.entries(enemyAttackCoords).forEach(function (_a) {
                var enemyAttack = _a[1];
                Object.values(enemyAttack).forEach(function (enemyAttackCoord) {
                    Object.keys(availableCoords).forEach(function (availableItemOrigin) {
                        var availableColumnCoords = availableCoords[availableItemOrigin];
                        if (availableColumnCoords.includes(enemyAttackCoord.coord) &&
                            availableItemOrigin !== enemyAttackCoord.destroyItemCoord) {
                            var defendCoordItem = {
                                coord: enemyAttackCoord.coord,
                                inDangerCoord: enemyAttackCoord.destroyItemCoord,
                            };
                            if (defendCoords[availableItemOrigin]) {
                                defendCoords[availableItemOrigin].push(defendCoordItem);
                            }
                            else {
                                defendCoords[availableItemOrigin] = [defendCoordItem];
                            }
                        }
                    });
                });
            });
            return defendCoords;
        };
        _this.getItemsByColor = function (color) {
            return Object.values(_this.board)
                .filter(function (_a) {
                var item = _a.item;
                return (item === null || item === void 0 ? void 0 : item.color) === color;
            })
                .map(function (_a) {
                var item = _a.item;
                return item;
            });
        };
        _this.getAvailableColumns = function (coord, movement) {
            if (_this.isEmpty(coord))
                return [];
            var columns = (0, getAvailableColumns_1.default)(coord, movement);
            var availableColumns = {};
            var captureAvailableColumns = {};
            var item = _this.getItem(coord);
            Object.keys(columns).forEach(function (key) {
                var _a;
                availableColumns[key] = [];
                var isFoundCapture = false;
                for (var i = 0; i < columns[key].length; i += 1) {
                    var currentCoord = columns[key][i];
                    if (!_this.isExistCoord(currentCoord))
                        continue;
                    if (_this.isEmpty(currentCoord)) {
                        availableColumns[key].push(currentCoord);
                        continue;
                    }
                    else if (isFoundCapture) {
                        break;
                    }
                    var nextCoordItem = _this.getItem(currentCoord);
                    if ((nextCoordItem === null || nextCoordItem === void 0 ? void 0 : nextCoordItem.color) === item.color) {
                        break;
                    }
                    else if (!isFoundCapture &&
                        nextCoordItem &&
                        nextCoordItem.color !== item.color) {
                        var direction = _this.getDirection(coord, currentCoord);
                        var movementRule = (_a = {
                                stepCount: 1
                            },
                            _a[direction] = true,
                            _a);
                        var afterCoord = Object.values((0, getAvailableColumns_1.default)(currentCoord, movementRule))
                            .filter(function (arr) { return arr.length; })
                            .flat()[0];
                        var afterItem = _this.getItem(afterCoord);
                        if (afterItem)
                            break;
                        if (_this.isEmpty(afterCoord)) {
                            availableColumns[key] = [afterCoord];
                            captureAvailableColumns[key] = true;
                            isFoundCapture = true;
                        }
                        else {
                            break;
                        }
                    }
                }
            });
            var resultCoords = {};
            var isFoundAnySuccessDirection = Object.values(captureAvailableColumns).some(function (direction) { return direction; });
            Object.keys(availableColumns).forEach(function (key) {
                if (!isFoundAnySuccessDirection) {
                    resultCoords[key] = _.uniq(availableColumns[key]);
                }
                else if (captureAvailableColumns[key]) {
                    resultCoords[key] = _.uniq(availableColumns[key]);
                }
            });
            return Object.values(resultCoords).flat();
        };
        return _this;
    }
    InternationalCheckersBoard.prototype.init = function () {
        var _this = this;
        var whiteItemCoords = '0|1 0|3 0|5 0|7 0|9 1|0 1|2 1|4 1|6 1|8 2|1 2|3 2|5 2|7 2|9 3|0 3|2 3|4 3|6 3|8';
        var blackItemCoords = '6|1 6|3 6|5 6|7 6|9 7|0 7|2 7|4 7|6 7|8 8|1 8|3 8|5 8|7 8|9 9|0 9|2 9|4 9|6 9|8';
        whiteItemCoords.split(' ').forEach(function (coord) {
            _this.setItem(coord, new item_1.default({ color: 'white' }));
        });
        blackItemCoords.split(' ').forEach(function (coord) {
            _this.setItem(coord, new item_1.default({ color: 'black' }));
        });
        return this;
    };
    InternationalCheckersBoard.prototype.reset = function () {
        Object.keys(this.board).forEach(this.removeItem);
        this.init();
    };
    InternationalCheckersBoard.prototype.getItemsBetweenTwoCoords = function (fromCoord, toCoord) {
        var _this = this;
        var direction = this.getDirection(fromCoord, toCoord);
        var distance = this.getDistanceBetweenTwoCoords(fromCoord, toCoord);
        var convertDirection = {
            top: 'y',
            bottom: 'y',
            left: 'x',
            right: 'x',
        };
        var stepCount = Math.abs(distance[convertDirection[direction]]) || 1;
        var movement = { stepCount: stepCount };
        movement[direction] = true;
        var betweenCoords = [];
        return betweenCoords
            .concat.apply(betweenCoords, Object.values((0, getAvailableColumns_1.default)(fromCoord, movement))).filter(function (coord) { return !_this.isEmpty(coord); });
    };
    return InternationalCheckersBoard;
}(board_1.default));
exports.default = InternationalCheckersBoard;
