"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const useCoord_1 = require("../../../utils/useCoord");
const board_1 = require("./board");
const simulate_1 = require("./simulate");
class Bot extends board_1.default {
    constructor(board) {
        super();
        this.attack = (color, { onAttack }) => {
            const attacks = this.getAttacks(color);
            const attackCoords = Object.keys(attacks);
            if (!attackCoords.length)
                return false;
            let selectedItemCoord;
            let lastCoord;
            attackCoords.forEach((coord) => {
                const attackItem = this.getItem(coord);
                if (attackItem.color !== color)
                    return;
                if (attackItem.selected)
                    selectedItemCoord = coord;
                lastCoord = coord;
            });
            if (!selectedItemCoord) {
                let maxComboCount = 0;
                let lastFowardRowId = null;
                attackCoords.forEach((coord) => {
                    const currentComboCount = this.getComboCount(attacks[coord]);
                    if (currentComboCount > maxComboCount) {
                        maxComboCount = currentComboCount;
                        selectedItemCoord = coord;
                    }
                    const isWhite = color === 'white' ? true : false;
                    const [rowId] = (0, useCoord_1.default)(this.getAfterAttackCoord(attacks[coord]));
                    if (!lastFowardRowId)
                        lastFowardRowId = rowId;
                    if (isWhite ? rowId >= lastFowardRowId : rowId <= lastFowardRowId) {
                        lastFowardRowId = rowId;
                        lastCoord = coord;
                    }
                });
                const everyComboCountIsSame = attackCoords.every((coord) => this.getComboCount(attacks[coord]) === maxComboCount);
                if (everyComboCountIsSame) {
                    selectedItemCoord = lastCoord;
                }
            }
            const selectedCoord = selectedItemCoord || lastCoord;
            const selectedAttack = attacks[selectedCoord];
            this.selectItem(selectedCoord);
            onAttack === null || onAttack === void 0 ? void 0 : onAttack(selectedAttack);
            return true;
        };
        this.defend = (color, { onDefend }) => {
            const defends = this.getDefends(color);
            const defendCoords = [...defends.keys()];
            let selectedItemCoord;
            let lastCoord;
            let minDefendCount = 20;
            defendCoords.forEach((coord) => {
                const currentDefendCount = this.getDefendCount(defends.get(coord));
                if (currentDefendCount < minDefendCount) {
                    minDefendCount = currentDefendCount;
                    selectedItemCoord = coord;
                }
                lastCoord = coord;
            });
            const everyComboCountIsSame = defendCoords.every((coord) => this.getDefendCount(defends.get(coord)) === minDefendCount);
            if (everyComboCountIsSame) {
                selectedItemCoord = lastCoord;
            }
            const selectedCoord = selectedItemCoord || lastCoord;
            if (!selectedCoord)
                return false;
            const selectedDefend = defends.get(selectedCoord);
            this.selectItem(selectedItemCoord);
            onDefend === null || onDefend === void 0 ? void 0 : onDefend(selectedDefend);
            return true;
        };
        this.move = (color, { onMove }) => {
            const movements = this.getAvailableCoordsByColor(color);
            const hasDangerMoves = new Map();
            const safeMoves = new Map();
            [...movements.entries()].forEach(([coord, columns]) => {
                columns.forEach((columnCoord) => {
                    (0, simulate_1.default)(this.board, (virtualBoard) => {
                        virtualBoard.moveItem(coord, columnCoord);
                        const enemyColor = color === 'white' ? 'black' : 'white';
                        const enemyAttacks = virtualBoard.getAttacks(enemyColor);
                        if (enemyAttacks.size) {
                            hasDangerMoves.set(coord, enemyAttacks.size);
                        }
                        else {
                            safeMoves.set(coord, enemyAttacks.size);
                        }
                    });
                });
            });
            const currentMoves = safeMoves.size ? safeMoves : hasDangerMoves;
            let selectedCoord;
            let minDangerCount = 20;
            for (const [moveCoord, inDangerCount] of currentMoves.entries()) {
                if (inDangerCount <= minDangerCount) {
                    console.log(moveCoord, inDangerCount);
                    minDangerCount = inDangerCount;
                    selectedCoord = moveCoord;
                }
            }
            // if (!selectedCoord) return false;
            const selecetedMove = movements.get(selectedCoord);
            console.log('selectedMove', selectedCoord, movements);
            this.selectItem(selectedCoord);
            console.log(selectedCoord, selecetedMove[0]);
            onMove === null || onMove === void 0 ? void 0 : onMove({ fromCoord: selectedCoord, toCoord: selecetedMove[0] });
            return true;
        };
        this.autoPlay = (color, { onAttack, onDefend, onMove }) => {
            const playedAttack = this.attack(color, { onAttack });
            if (playedAttack)
                return;
            const playedDefend = this.defend(color, { onDefend });
            if (playedDefend)
                return;
            this.move(color, { onMove });
        };
        this.board = board;
    }
}
exports.default = Bot;
